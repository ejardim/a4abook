[["fitting.html", "7 Fitting 7.1 Fishing mortality submodel (\\(F_{ay}\\)) 7.2 Abundance indices catchability submodel (\\(Q_{ays}\\)) 7.3 Stock-recruitment submodel (\\(R_y\\)) 7.4 Observation variance submodel (\\(\\{\\sigma^2_{ay}, \\tau^2_{ays}\\}\\)) 7.5 Initial year abundance submodel (\\(N_{a,y=1}\\)) 7.6 More models 7.7 Working with covariates 7.8 Assessing files 7.9 Missing observations in the catch matrix or index", " 7 Fitting The a4a stock assessment framework is implemented in R through the method sca(). The method call requires as a minimum a FLStock object and a FLIndices or FLindex object, in which case the default submodels will be set by the method. Having described building blocks, basic formulations and effects available to build a submodel’s model, it’s important to look into specific formulations and relate them to commonly known representations. Note that although a large number of formulations are available for each submodel, the user must carefully decide on the full stock assessment model being build and avoid over-parameterize. Over-parametrization may lead to non-convergence, but may also end up not being very useful for prediction/forecasting, which is one of the main objectives of stock assessment. library(FLa4a) data(ple4) data(ple4.indices) data(ple4.index) fit &lt;- sca(ple4, ple4.indices) stk &lt;- ple4 + fit Figure 7.1: Stock summary Submodels that are not explicitly defined will be set by default using the relevant call to defaultFmod(), defaultQmod, defaultSRmod(), defaultN1mod or defaultVmod(). These methods will use the length of the time series and number of age groups to define the models. The show method for a4aFit objects display the models used for the fit. ## a4a model fit for: PLE ## ## Call: ## .local(stock = stock, indices = indices) ## ## Time used: ## Pre-processing Running a4a Post-processing Total ## 1.2818902 14.1500819 0.3325787 15.7645507 ## ## Submodels: ## fmodel: ~te(age, year, k = c(6, 30), bs = &quot;tp&quot;) + s(age, k = 6) ## srmodel: ~factor(year) ## n1model: ~s(age, k = 3) ## qmodel: ## BTS-Isis-early: ~s(age, k = 6) ## BTS-Combined (ISIS and TRIDENS): ~s(age, k = 6) ## SNS: ~s(age, k = 5) ## BTS-Combined (all): ~s(age, k = 6) ## IBTS_Q3: ~s(age, k = 6) ## IBTS_Q1: ~s(age, k = 5) ## vmodel: ## catch: ~s(age, k = 3) ## BTS-Isis-early: ~1 ## BTS-Combined (ISIS and TRIDENS): ~1 ## SNS: ~1 ## BTS-Combined (all): ~1 ## IBTS_Q3: ~1 ## IBTS_Q1: ~1 To set specific submodels the user has to write the relevant R formula and include it in the call. The arguments for each submodel are self-explanatory: fishing mortality is ‘fmodel’, indices’ catchability is ‘qmodel’, stock-recruitment is ‘srmodel’, observation variance is ‘vmodel’ and for initial year’s abundance is ‘n1model’. The following model comes closer to the official stock assessment of North Sea plaice, as such we’ll name it fit0 and keep it for future comparisons. fmod0 &lt;- ~s(age, k=6)+s(year, k=10)+te(age, year, k=c(3,8)) qmod0 &lt;- list(~s(age, k = 4), ~s(age, k = 3), ~s(age, k = 3) + year, ~s(age, k = 3), ~s(age, k = 4), ~s(age, k = 6)) srmod0 &lt;- ~ s(year, k=20) vmod0 &lt;- list(~s(age, k=4), ~1, ~1, ~1, ~1, ~1, ~1, ~1) n1mod0 &lt;- ~ s(age, k=3) fit0 &lt;- sca(ple4, ple4.indices, fmodel=fmod0, qmodel=qmod0, srmodel=srmod0, n1model=n1mod0, vmodel=vmod0) stk0 &lt;- ple4 + fit0 Figure 7.2: Stock summary - close to official assessment As before by calling the fitted object, the submodels’ formulas are printed in the console: ## a4a model fit for: PLE ## ## Call: ## .local(stock = stock, indices = indices, fmodel = ..1, qmodel = ..2, ## srmodel = ..3, n1model = ..4, vmodel = ..5) ## ## Time used: ## Pre-processing Running a4a Post-processing Total ## 0.79011393 3.55707216 0.08485723 4.43204331 ## ## Submodels: ## fmodel: ~s(age, k = 6) + s(year, k = 10) + te(age, year, k = c(3, 8)) ## srmodel: ~s(year, k = 20) ## n1model: ~s(age, k = 3) ## qmodel: ## BTS-Isis-early: ~s(age, k = 4) ## BTS-Combined (ISIS and TRIDENS): ~s(age, k = 3) ## SNS: ~s(age, k = 3) + year ## BTS-Combined (all): ~s(age, k = 3) ## IBTS_Q3: ~s(age, k = 4) ## IBTS_Q1: ~s(age, k = 6) ## vmodel: ## catch: ~s(age, k = 4) ## BTS-Isis-early: ~1 ## BTS-Combined (ISIS and TRIDENS): ~1 ## SNS: ~1 ## BTS-Combined (all): ~1 ## IBTS_Q3: ~1 ## IBTS_Q1: ~1 There are a set of methods for a4a fit objects which help manipulating sca() results, namely: [+:] update the stock object with the fitted fishing mortalities, population abundance and catch in numbers at age; can be applied to FLStocks and a4aFits objects as well. The following subsections describe common formulations used to define submodels. Although the formulas are tailored to specific submodels — e.g., a separable model for \\(F\\) — they can, in principle, be applied to any submodel. The sca method is agnostic to the model setup and will attempt to fit the model regardless of its specification. However, from a statistical standpoint, convergence may fail if the model is not well specified. From a fisheries modeling perspective, limitations arise in how the model is interpreted. For example, if a scientific survey is modeled with a year effect, the user is implicitly assuming that the survey’s selectivity has changed over time. Consequently, the model may attribute part of the observed trend in the survey data to changes in selectivity rather than to changes in abundance. 7.1 Fishing mortality submodel (\\(F_{ay}\\)) 7.1.1 Separable model One of the most useful models for fishing mortality is one in which ‘age’ and ‘year’ effects are independent, that is, where the shape of the selection pattern does not change over time, but the overall level of fishing mortality do. Commonly called a ‘separable model’. A full separable model in a4a is written using the factor function which converts age and year effects into categorical values, forcing a different coefficient to be estimated for each level of both effects. This model has \\(age x year\\) number of parameters. fmod1 &lt;- ~ factor(age) + factor(year) fit1 &lt;- sca(ple4, ple4.indices, fmodel=fmod1, fit=&quot;MP&quot;) One can reduce the number of parameters and add dependency along both effects, although still keeping independence of each other, by using smoothers rather than factor. We’re using the North Sea Plaice data, and since it has 10 ages we will use a simple rule of thumb that the spline should have fewer than \\(\\frac{10}{2} = 5\\) degrees of freedom, and so we opt for 4 degrees of freedom. We will also do the same for year and model the change in \\(F\\) through time as a smoother with 20 degrees of freedom. fmod2 &lt;- ~ s(age, k=4) + s(year, k=20) fit2 &lt;- sca(ple4, ple4.indices, fmodel=fmod2, fit=&quot;MP&quot;) An interesting extension of the separable model is the ‘double separable’ where a third factor or smoother is added for the cohort effect. fmod3 &lt;- ~ s(age, k=4) + s(year, k=20) + s(as.numeric(year-age), k=10) fit3 &lt;- sca(ple4, ple4.indices, fmodel=fmod3, fit=&quot;MP&quot;) ## Warning: *** ~s(age, k = 4) + s(year, k = 20) + s(as.numeric(year - age), k = 10) has 1 too many parameter(s)!! ## i will remove the redundant ones: ## s(as.numeric(year - age)).9 Figures 7.3 and 7.4 depicts the three models selectivities for each year. Each separable model has a single selectivity that changes it’s overall scale in each year, while the double separable introduces some variability over time by modeling the cohort factor. Figure 7.3: Selection pattern of separable models. Each line represents the selection pattern in a specific year. Independent age and year effects (factor), internally dependent age and year (smooth), double separable (double). Figure 7.4: Fishing mortality of separable models. Independent age and year effects (factor), internally dependent age and year (smooth), double separable (double). 7.1.2 Model with age-year interaction A non-separable model, where we consider age and year to interact can be modeled by a smooth interaction term with a tensor product of cubic splines, the te method (Figure 7.5), again borrowed from mgcv ((R-mgcv?)). fmod &lt;- ~ te(age, year, k = c(4,20)) fit &lt;- sca(ple4, ple4.indices, fmod) Figure 7.5: Fishing mortality smoothed non-separable model In this example fishing mortalities are linked across age and time. What if we want to free up a specific age class because in the residuals we see a consistent pattern. This can happen, for example, if the spatial distribution of juveniles is disconnected to the distribution of adults. The fishery focuses on the adult fish, and therefore the \\(F\\) on young fish is a function of the distribution of the juveniles and could deserve a specific model. This can be achieved by adding a component for the year effect on age 1 (Figure 7.6). We’ll use s’s argument by to define the ages that the model will apply to. The as.numeric method over age==1, will result in a matrix that will be \\(1\\) for ages 1 and \\(0\\) for the other ages, effectively removing those ages from the s model. Furthermore, by not removing age 1 from the te component we’re in effect adding the two estimates for age 1. fmod &lt;- ~ te(age, year, k = c(3,20)) + s(year, k = 5, by = as.numeric(age==1)) fit2 &lt;- sca(ple4, ple4.indices, fmod) Figure 7.6: Fishing mortality age-year interaction model with extra age 1 smoother. 7.1.3 Constant selectivity for contiguous ages or years To set these models we’ll use the method replace() to define which ages or years will be modelled together. The following example shows replace() in operation. The dependent variables used in the model will be changed and attributed the same age or year, as such during the fit observations of those ages or years with will be seen as replicates. One can think of it as sharing the same mean value, which will be estimated by the model. age &lt;- 1:10 # last age same as previous replace(age, age&gt;9, 9) ## [1] 1 2 3 4 5 6 7 8 9 9 # all ages after age 6 replace(age, age&gt;6, 6) ## [1] 1 2 3 4 5 6 6 6 6 6 year &lt;- 1950:2010 replace(year, year&gt;2005, 2005) ## [1] 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 ## [16] 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 ## [31] 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 ## [46] 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2005 2005 2005 2005 ## [61] 2005 In the \\(F\\) submodel one can use this method to fix the estimation of \\(F\\) in the plus group to be the same as in the last non-aggregated age. fmod &lt;- ~ s(replace(age, age&gt;9, 9), k=4) + s(year, k=20) fit &lt;- sca(ple4, ple4.indices, fmod) Figure 7.7: F-at-age fixed above age 9 Or estimate the average \\(F\\) in the most recent years, instead of averaging after the assessment to compute the statu quo selection pattern. fmod &lt;- ~ s(age, k=4) + s(replace(year, year&gt;2013, 2013), k=20) fit &lt;- sca(ple4, ple4.indices, fmod) Figure 7.8: F-at-age fixed for the most recent 5 years 7.1.4 Time blocks selectivity To define blocks of data sca() uses the method breakpts(), which creates a factor from a vector with levels defined by the second argument. year &lt;- 1950:2010 # two levels separated in 2000 breakpts(year, 2000) ## [1] (1949,2000] (1949,2000] (1949,2000] (1949,2000] (1949,2000] (1949,2000] ## [7] (1949,2000] (1949,2000] (1949,2000] (1949,2000] (1949,2000] (1949,2000] ## [13] (1949,2000] (1949,2000] (1949,2000] (1949,2000] (1949,2000] (1949,2000] ## [19] (1949,2000] (1949,2000] (1949,2000] (1949,2000] (1949,2000] (1949,2000] ## [25] (1949,2000] (1949,2000] (1949,2000] (1949,2000] (1949,2000] (1949,2000] ## [31] (1949,2000] (1949,2000] (1949,2000] (1949,2000] (1949,2000] (1949,2000] ## [37] (1949,2000] (1949,2000] (1949,2000] (1949,2000] (1949,2000] (1949,2000] ## [43] (1949,2000] (1949,2000] (1949,2000] (1949,2000] (1949,2000] (1949,2000] ## [49] (1949,2000] (1949,2000] (1949,2000] (2000,2010] (2000,2010] (2000,2010] ## [55] (2000,2010] (2000,2010] (2000,2010] (2000,2010] (2000,2010] (2000,2010] ## [61] (2000,2010] ## Levels: (1949,2000] (2000,2010] # five periods with equal interval breakpts(year, seq(1949, 2010, length=6)) ## [1] (1949,1961.2] (1949,1961.2] (1949,1961.2] (1949,1961.2] ## [5] (1949,1961.2] (1949,1961.2] (1949,1961.2] (1949,1961.2] ## [9] (1949,1961.2] (1949,1961.2] (1949,1961.2] (1949,1961.2] ## [13] (1961.2,1973.4] (1961.2,1973.4] (1961.2,1973.4] (1961.2,1973.4] ## [17] (1961.2,1973.4] (1961.2,1973.4] (1961.2,1973.4] (1961.2,1973.4] ## [21] (1961.2,1973.4] (1961.2,1973.4] (1961.2,1973.4] (1961.2,1973.4] ## [25] (1973.4,1985.6] (1973.4,1985.6] (1973.4,1985.6] (1973.4,1985.6] ## [29] (1973.4,1985.6] (1973.4,1985.6] (1973.4,1985.6] (1973.4,1985.6] ## [33] (1973.4,1985.6] (1973.4,1985.6] (1973.4,1985.6] (1973.4,1985.6] ## [37] (1985.6,1997.8] (1985.6,1997.8] (1985.6,1997.8] (1985.6,1997.8] ## [41] (1985.6,1997.8] (1985.6,1997.8] (1985.6,1997.8] (1985.6,1997.8] ## [45] (1985.6,1997.8] (1985.6,1997.8] (1985.6,1997.8] (1985.6,1997.8] ## [49] (1997.8,2010] (1997.8,2010] (1997.8,2010] (1997.8,2010] ## [53] (1997.8,2010] (1997.8,2010] (1997.8,2010] (1997.8,2010] ## [57] (1997.8,2010] (1997.8,2010] (1997.8,2010] (1997.8,2010] ## [61] (1997.8,2010] ## 5 Levels: (1949,1961.2] (1961.2,1973.4] (1973.4,1985.6] ... (1997.8,2010] Note seq() computes ‘left-open’ intervals, which means that to include 1950 the sequence must start one year earlier. These methods can be used to create discrete time series, for which a different selection pattern is allowed in each block. This is called an interaction in statistical modelling parlance, and typically a * denotes an interaction term, for smoothers an interaction is achieved using the by argument. When this argument is a factor a replicate of the smooth is produced for each factor level. In the next case we’ll use the breakpts() to split the time series at 1990, although keeping the same shape in both periods, a thin plate spline with 3 knots (Figure 7.9). fmod &lt;- ~s(age, k = 3, by = breakpts(year, 1990)) fit &lt;- sca(ple4, ple4.indices, fmod) Figure 7.9: F-at-age in two periods using in both cases a thin plate spline with 3 knots 7.1.5 Time changing selectivity In many cases, it may be desirable to allow the selection pattern to evolve over time, from year to year. Again there are several ways to do this, one way is to estimate a mean selection pattern, while also allowing \\(F\\) to vary over time for each age. This is like a separable smoother over year, with ‘age blocks’ so, looking back at previous examples, we have: fmodel &lt;- ~ s(year, k = 15, by = factor(age)) + s(age, k = 4) This is a type of interaction between age and year, but the only connection (or correlation) across ages is via the smoother on age, however there are still 15 degrees of freedom for each age, so the model 10 x 15 + 4 = 154 degrees of freedom. To include correlation across ages and years together the tensor product (te()) is used, this has the effect of restricting the flexibility of the model for \\(F\\). In the following, there is a smoother in 2 dimensions (age and year) where there is 5 degrees of freedom in the age direction, and 15 in the year dimension, resulting in a total of 5 x 15 = 65 degrees of freedom fmodel &lt;- ~ te(age, year, k = c(5, 15)) Often the above formulations provide too much flexibility, and a more complicated specification, but simpler model is preferable: fmodel &lt;- ~ s(age, k = 4) + s(year, k = 15) + te(age, year, k = c(3, 5)) in the above model, the main effects for age and year still have similar flexibility to the full tensor model, however, the interaction (or the change in F at age over time) has been restricted, so that the full model now has 4 + 15 + 3 x 5 = 34 degrees of freedom. 7.1.6 Closed form selection pattern One can use a closed form for the selection pattern. The only requirement is to be able to write it as a R formula, the example below uses a logistic form. fmod &lt;- ~ I(1/(1+exp(-age))) fit &lt;- sca(ple4, ple4.indices, fmod) Figure 7.10: F-at-age logistic 7.2 Abundance indices catchability submodel (\\(Q_{ays}\\)) The catchability submodel is set up the same way as the \\(F\\) submodel. The only difference is that the submodel is set up as a list of formulas, where each formula relates with one abundance index. There’s no limitation in the number of indices or type that can be used for a fit. It’s the analyst that has to decide based on her/his expertise and knowledge of the stock and fleet dynamics. In the following examples we’ll use a single index instead of all available indices for plaice in ICES area 4, to simplify the code and examples. 7.2.1 Catchability submodel for age based indices The first model shown is simply a dummy effect on age, which means that one coefficient will be estimated for each age. Note this kind of model considers each level of the factor to be independent from the others levels (Figure 7.11). qmod &lt;- list(~factor(age)) fit &lt;- sca(ple4, ple4.index, qmodel=qmod) Figure 7.11: Catchability age independent model If one considers catchability at a specific age to be dependent on catchability on the other ages, similar to a selectivity modelling approach, one option is to use a smoother at age, and let the data ‘speak’ regarding the shape (Figure 7.12). qmod &lt;- list(~ s(age, k=4)) fit &lt;- sca(ple4, ple4.indices[1], qmodel=qmod) Figure 7.12: Catchability smoother age model Finally, one may want to investigate a trend in catchability with time, very common in indices built from CPUE data. In the example given here we’ll use a linear trend in time, set up by a simple linear model (Figure 7.13). qmod &lt;- list( ~ s(age, k=4) + year) fit &lt;- sca(ple4, ple4.indices[1], qmodel=qmod) Figure 7.13: Catchability with a linear trend in year 7.2.2 Catchability submodel for age aggregated biomass indices The previous section focused on age-disaggregated indices, which are most often reported as standardized number of individuals, e.g. number of individuals caught per hour. Age-aggregated indices (such as CPUE, biomass, DEPM, etc.) may also be used to tune the population’s biomass in terms of weight. These indices are linked either to the total biomass or to the weight of a specific group of age classes, defined by the age range set in the object. In such cases, a different index class must be used: FLIndexBiomass. This class uses a vector named index with an age dimension labeled as ‘all’. The qmodel should be specified without age-specific factors, although it may still include a ‘year’ component and relevant covariates, if needed. # simulating a biomass index (note the name of the first dimension element) using # the ple4 biomass and an arbritary catchability of 0.001 plus a lognormal error. dnms &lt;- list(age=&quot;all&quot;, year=range(ple4)[&quot;minyear&quot;]:range(ple4)[&quot;maxyear&quot;]) bioidx &lt;- FLIndexBiomass(FLQuant(NA, dimnames=dnms)) index(bioidx) &lt;- stock(ple4)*0.001 index(bioidx) &lt;- index(bioidx)*exp(rnorm(index(bioidx), sd=0.1)) range(bioidx)[c(&quot;startf&quot;,&quot;endf&quot;)] &lt;- c(0,0) # note the name of the first dimension element index(bioidx) ## An object of class &quot;FLQuant&quot; ## , , unit = unique, season = all, area = unique ## ## year ## age 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 ## all 392 409 451 527 423 659 530 501 626 603 521 525 536 381 ## year ## age 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 ## all 450 387 423 375 420 482 554 374 434 452 450 557 540 470 ## year ## age 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 ## all 642 785 787 627 629 579 527 513 388 327 350 321 323 351 ## year ## age 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 ## all 379 370 387 399 361 345 398 417 461 535 731 697 809 835 ## year ## age 2013 2014 2015 2016 2017 ## all 923 843 1045 1020 1084 ## ## units: t # fitting the model fit &lt;- sca(ple4, FLIndices(bioidx), qmodel=list(~1)) To estimate a constant selectivity over time one used the model \\(\\sim 1\\), resulting in the following estimate: predict(fit)$qmodel[[1]][1,drop=TRUE] ## [1] 0.0009827141 The next code shows an example where the biomass index refers to age groups 2 to 4, e.g. the CPUE of a fleet that targets these particular ages. # creating the index dnms &lt;- list(age=&quot;all&quot;, year=range(ple4)[&quot;minyear&quot;]:range(ple4)[&quot;maxyear&quot;]) bioidx &lt;- FLIndexBiomass(FLQuant(NA, dimnames=dnms)) # but now use only ages 2:4 index(bioidx) &lt;- tsb(ple4[ac(2:4)])*0.001 index(bioidx) &lt;- index(bioidx)*exp(rnorm(index(bioidx), sd=0.1)) range(bioidx)[c(&quot;startf&quot;,&quot;endf&quot;)] &lt;- c(0,0) # to pass this information to the model one needs to specify an age range range(bioidx)[c(&quot;min&quot;,&quot;max&quot;)] &lt;- c(2,4) # fitting the model fit &lt;- sca(ple4, FLIndices(bioidx), qmodel=list(~1)) Once more the estimate value is not very far from the simulated one, 0.001. predict(fit)$qmodel[[1]][1,drop=TRUE] ## [1] 0.0009746023 7.2.3 Catchability submodel for single age indices Similar to age aggregated indices one may have an index that relates only to one age, like a recruitment index. In this case the FLIndex object must have in the first dimension the age it refers to. The fit uses the index to tune the population abundance for the specific age. As for biomass indices, the qmodel should be set without age factors, although it can have a ‘year’ component and covariates if needed. idx &lt;- ple4.index[1] fit &lt;- sca(ple4, FLIndices(recidx=idx), qmodel=list(~1)) # the estimated catchability is predict(fit)$qmodel[[1]][1,drop=TRUE] ## [1] 0.06007767 7.3 Stock-recruitment submodel (\\(R_y\\)) The S/R submodel is a special case, in the sense that it can be set up with the same linear tools as the \\(F\\) and \\(Q\\) models, but it can also use some hard coded models. The example shows how to set up a simple dummy model with factor(), a smooth model with s(), a Ricker model (ricker()), a Beverton and Holt model (bevholt()), a hockey stick model (hockey()), and a geometric mean model (geomean()). See Figure 7.14 for results. As mentioned before, the ‘structural’ models have a fixed variance, which must be set by defining the coefficient of variation. srmod &lt;- ~ factor(year) fit &lt;- sca(ple4, ple4.indices, srmodel=srmod) srmod &lt;- ~ s(year, k=15) fit1 &lt;- sca(ple4, ple4.indices, srmodel=srmod) srmod &lt;- ~ ricker(CV=0.1) fit2 &lt;- sca(ple4, ple4.indices, srmodel=srmod) srmod &lt;- ~ bevholt(CV=0.1) fit3 &lt;- sca(ple4, ple4.indices, srmodel=srmod) srmod &lt;- ~ hockey(CV=0.1) fit4 &lt;- sca(ple4, ple4.indices, srmodel=srmod) srmod &lt;- ~ geomean(CV=0.1) fit5 &lt;- sca(ple4, ple4.indices, srmodel=srmod) Figure 7.14: Recruitment estimates since 1960 by each stock-recruitment model. 7.4 Observation variance submodel (\\(\\{\\sigma^2_{ay}, \\tau^2_{ays}\\}\\)) The variance model allows the user to set up the shape of the observation variances \\(\\sigma^2_{ay}\\) and \\(\\tau^2_{ays}\\). This is an important subject for fisheries data used as input to stock assessment models. The defaults assume a U-shape like model for catch-at-age and constant variance for abundance indices. The first relies on the fact that it’s common to have more precision on the most represented ages and less precision on the less frequent ages which tend to be the younger and older individuals. These sizes are less caught by the fleets and as such do not appear as often at the auction markets samples. With regards to the abundance indices, one assumes a scientific survey to have a well designed sampling scheme and protocols which keep observation error at similar levels across ages. # reference model with constant variance for the survey index vmod &lt;- list(~s(age, k=3), ~1) fit1 &lt;- sca(ple4, ple4.index, vmodel=vmod) # to compare - survey index variance modelled has a U-shape smoother vmod &lt;- list(~s(age, k=3), ~s(age, k=3)) fit2 &lt;- sca(ple4, ple4.index, vmodel=vmod) Variance estimated for the survey is constant at 0.476 while for catches using the U-shape model, fitted with a smoother, changes with ages (Figure 7.15). Figure 7.15: Abundance index observation variance estimate Observation variance options have an impact in the final estimates of population abundance, which can be seen in Figure 7.16. Figure 7.16: Population estimates using two different variance models for the survey 7.5 Initial year abundance submodel (\\(N_{a,y=1}\\)) The submodel for the stock number at age in the first year of the time series is set with the usual tools. The model deals with the shape of the population abundance in a single year and as such the year effect shouldn’t be included (Figure 7.17). This model has its influence limited to the initial lower triangle of the population matrix, which in assessments with long time series doesn’t make much difference. Nevertheless, when modelling stocks with short time series in relation to the number of ages present, it becomes more important and should be given proper attention. # model with smoother n1mod &lt;- ~s(age, k=4) fit1 &lt;- sca(ple4, ple4.indices, n1model=n1mod) # model with factor n1mod &lt;- ~factor(age) fit2 &lt;- sca(ple4, ple4.indices, n1model=n1mod) Figure 7.17: Nay=1 models The impact in the overall perspective of the stock status is depicted in Figure 7.18. Most of the changes happen in the beggining of the time series, although due to the impact on the estimates of other submodels’ parameters it can have an impact over the full time series. Figure 7.18: Population estimates using two different variance models 7.6 More models More complicated models can be built with these tools. The limitation is going to be the potential overparametrization of the model and the failure to fit if the data isn’t informative enough. For example, Figure 7.19 shows a model where the age effect is modelled as a smoother throughout years independent from each other, with the exception of ages 9 and 10 which share their parameters. fmod &lt;- ~ factor(age) + s(year, k=10, by = breakpts(age, c(0:8))) fit &lt;- sca(ple4, ple4.indices, fmod) Figure 7.19: F-at-age as thin plate spline with 3 knots for each age A quite complex model that implements a cohort effect can be set through the following formula. Figure 7.20 shows the resulting fishing mortality. Note that in this case we end up with a variable \\(F\\) pattern over time, but rather than using 4 * 10 = 40 parameters, it uses, 4 + 10 + 10 = 24. fmodel &lt;- ~ s(age, k = 4) + s(pmax(year - age, 1957), k = 10) + s(year, k = 10) fit &lt;- sca(ple4, ple4.indices, fmodel=fmodel) Figure 7.20: F-at-age with a cohort effect. The following model is applied to the vmodel and it introduces an time trend to reflect the increase in precision in more recent years with improvements in sampling design and increase in sampling effort. vmod &lt;- list( ~ s(age, k = 3) + year, ~1, ~1, ~1, ~1, ~1, ~1 ) fit &lt;- sca(ple4, ple4.indices, vmodel=vmod) Figure 7.21: Catch at age variance model with a year effect. This model fits two smoothers to different sets of ages. fmod &lt;- ~s(age, k = 3, by = breakpts(age, 5)) + s(year, k = 10) fit &lt;- sca(ple4, ple4.indices, fmodel = fmod) Figure 7.22: Smoothers fitted to two sets of ages, 1 to 4 and 5 to 10. flsts &lt;- FLStocks(nowgt=ple4+fit0, wgt=ple4 + fit1) plot(flsts) 7.7 Working with covariates In linear model one can use covariates to explain part of the variance observed on the data that the ‘core’ model does not explain. The same can be done in the a4a framework. The example below uses the North Atlantic Oscillation (NAO) index to model recruitment. nao &lt;- read.table(&quot;https://www.cpc.ncep.noaa.gov/products/precip/CWlink/pna/norm.nao.monthly.b5001.current.ascii.table&quot;, skip=1, fill=TRUE, na.strings=&quot;-99.90&quot;) dnms &lt;- list(quant=&quot;nao&quot;, year=1950:2024, unit=&quot;unique&quot;, season=1:12, area=&quot;unique&quot;) nao &lt;- FLQuant(unlist(nao[,-1]), dimnames=dnms, units=&quot;nao&quot;) nao &lt;- seasonMeans(trim(nao, year=dimnames(stock.n(ple4))$year)) First by simply assuming that the NAO index drives recruitment (Figure 7.23). srmod &lt;- ~ s(nao, k=10) fit2 &lt;- sca(ple4, ple4.indices[1], qmodel=list(~s(age, k=4)), srmodel=srmod, covar=FLQuants(nao=nao)) Figure 7.23: Recruitment model with covariates. Using the NAO index as a recruitment index. In a second model we’re using the NAO index not to model recruitment directly but to model one of the parameters of the S/R function (Figure 7.24). srmod &lt;- ~ ricker(a=~nao, CV=0.25) fit3 &lt;- sca(ple4, ple4.indices[1], qmodel=list(~s(age, k=4)), srmodel=srmod, covar=FLQuants(nao=nao)) Figure 7.24: Recruitment model with covariates. Using the NAO index as a covariate for the stock-recruitment model parameters. Note that covariates can be added to any submodel using the linear model capabilities of R. 7.8 Assessing files The framework gives access to all files produced to run the ADMB fitting routine through the argument wkdir. When set up, all the ADMB files will be left in the directory. Note that the ADMB tpl file is distributed with the FLa4a. One can get it from your R library, under the folder [myRlib]/FLa4a/admb/. fit1 &lt;- sca(ple4, ple4.indices, wkdir=&quot;fit1run&quot;) 7.9 Missing observations in the catch matrix or index Missing observations are encoded as NA, and usually occur if there was no sampling for a year, or, since we model observations on the log scale, if the observation was zero. The a4a framework can deal with missing observations in the catches and indices. The example below shows how to set up a model with missing observations in the catch matrix, to demonstrate the effect of missing observations, using the default model settings. fit &lt;- sca(ple4, ple4.indices) ple4_missing &lt;- ple4 catch.n(ple4_missing)[ac(1:2), &quot;2013&quot;] &lt;- NA fit_missing &lt;- sca(ple4_missing, ple4.indices) In effect, the information on \\(F\\) and \\(Q\\) for the missing observations is inferred from the structural assumptions of the model. If a separable \\(F\\) model is used, the value of \\(F\\) at a given age is derived from its relationship with \\(F\\) at other ages in the same year, as well as from the temporal relationship of \\(F\\) across years for ages with available data. The same principle applies to any other submodel. The impact of missing observations is illustrated in Figure 7.25, which shows box plots of the predicted catch at age, incorporating estimation error. When observations are missing, the resulting estimates for those ages are both different and more uncertain. Additionally, the estimates for nearby years are affected, although the influence of the missing data diminishes with time—estimates from years further away converge toward those obtained using the full dataset. Figure 7.25: Stock estimates with missing observations. This is a simple example, but the same principle applies to more complex models. However, if there are many missing observations, the model cannot be too flexible; otherwise, it won’t be able to reliably estimate the missing data. In any case, one can always add more structure to the model to help address missing information. A common approach is to include a stock-recruitment relationship, which links the spawning stock biomass to recruitment. The example above would definitely benefit from this approach, as the missing information pertains to the first age group. See Figure ??, estimates are much more similar, although estimates from the fit to the missing data dataset show more uncertainty, as expected. # bevholt s/r CV was tweaked to give best results for the example fit2 &lt;- sca(ple4, ple4.indices, srmodel=~bevholt(CV=0.16)) fit_missing2 &lt;- sca(ple4_missing, ple4.indices, srmodel=~bevholt(CV=0.16)) Figure 7.26: Stock estimates with missing observations. Another point to note, is that if observations are systematically missing, for example due to the actual observation being below a detection limit, or zero, then the model may overestimate the true catch at age. This is a common problem in stock assessment models, and is not unique to the a4a framework. Proposed solutions to this issue are to replace zeros with a small number, or half of the smallest observed value. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
