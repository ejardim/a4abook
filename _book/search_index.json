[["uncertainty.html", "9 Uncertainty 9.1 The simulate and predict methods 9.2 Prediction uncertainty 9.3 confidence interval coverage 9.4 Propagate uncertainty into stock assessment", " 9 Uncertainty Uncertainty is a fundamental aspect of scientific advice, serving as a reflection of the inherent limitations within the knowledge base used to construct evidence and support scientific opinions. It highlights the gaps, variability, and potential biases present in data, methods, and modeling assumptions that underlie scientific conclusions. In fisheries science, a field that has evolved primarily to provide evidence-based advice for the sustainable exploitation of marine resources, acknowledging and addressing uncertainty is of major importance. Given the dynamic, complex, and partially observable nature of aquatic ecosystems, the need to systematically characterize and communicate uncertainty is paramount to ensuring robust and credible assessments (Privitera-Johnson &amp; Punt, 2020). In practice, failing to address uncertainty in fisheries advice can lead to over-exploitation, stock collapses, and reduced economic returns. Modern fisheries governance must therefore integrate uncertainty not only at the scientific level but also within decision-making and policy frameworks. Embracing uncertainty promotes a culture of precaution, transparency, and resilience, ensuring that fisheries remain productive and viable for future generations (Folkesson, 2010). In this section we’ll address two important elements of quantifying uncertainty in stock assessment results, prediction error and propagation of uncertainty across modelling stages. The two workhorses for this topic are predict() and simulate() which are implemented to work with sca fits of type \"assessment\". Note fit = \"MP\" doesn’t compute the variance-covariance matrix of the parameters, which is essential for simulating. This chapter is based on the following model: nsim &lt;- 250 fmod &lt;- ~s(age, k = 4) + s(year, k = 8) + s(year, k = 8, by = as.numeric(age == 0)) + s(year, k = 8, by = as.numeric(age == 4)) qmod &lt;- list(~I(1/(1 + exp(-age)))) fit0 &lt;- sca(hke1567, hke1567.idx, fmodel=fmod, qmodel=qmod) 9.1 The simulate and predict methods 9.1.1 predict() The predict method computes the quantities of interest using the estimated coefficients and the design matrix of the model, defined via the formulas in the submodels. The method uses a fitted model object, created by a call to sca, and returns a list with one element for each submodel, where each element is a FLQuants object. fit.pred &lt;- predict(fit0) lapply(fit.pred, names) ## $stkmodel ## [1] &quot;harvest&quot; &quot;rec&quot; &quot;ny1&quot; ## ## $qmodel ## [1] &quot;IND&quot; ## ## $vmodel ## [1] &quot;catch&quot; &quot;IND&quot; The stkmodel element reports harvest, rec and ny1. The qmodel reports one FLQuant for each index, and the vmodel element returns one FLQuant for catch (in fact catch.n) and one for each index. This allows easy access to the parameterised parts of the model, for example the initial population structure, ny1, can be accessed via fit.pred$stkmodel$ny1. ## An object of class &quot;FLQuant&quot; ## , , unit = unique, season = all, area = unique ## ## year ## age 2007 ## 0 366994 ## 1 33695 ## 2 4107 ## 3 803 ## 4 306 ## 5 187 ## ## units: 1000 If the fitted object has iterations, as after using the simulate method, which will be discussed in the next section, predict will be applied to each iter, generating distributions of the above mentioned quantities (Figure 9.1). Figure 9.1: Simulations from the model prediction of initial age structure 9.1.2 simulate() As the name implies simulate is used to generate simulations of the fit. It operates over objects of class a4aFitSA using the method mvrnorm() provided by the R package MASS (Venables and Ripley 2002). The method generates random draws from a multivariate normal distribution with mean given by the coefficients of the model, and variance matrix given by the estimated covariance matrix of the coefficients (in practice this is a submatrix of the inverse of the hessian matrix). The method approximates the joint distribution of the model parameters as a multivariate normal in the log space, which is inline with the assumption made by ADMB when fitting the model. This approach is called ‘parametric bootstrap’, and it’s a common method for generating uncertainty in the parameters of a model. simulate() operates at the submodel level, e.g. simulate(fit0@pars@qmodel, nsim=250), when called over a a4aFitSA object the method simply runs simulate() over each of the submodels. In this case it returns an object of the same class with model parameters replaced by nsim simulated parameters and updated slots stock.n, catch.n and harvest. Figure 9.2 depicts the distribution of a parameter, the observation error of the first survey index. Figure 9.2: Histogram of 250 draws from the approximate distribution of the estimate of survey observation error. In some simulation studies one needs to make sure the random draws are the same, which in R is obtained by explicitly setting the random seed with the method set.seed(). The same is achieved in this case as the example below shows. set.seed(1234) fit.sim1 &lt;- simulate(fit0, nsim = 250) set.seed(1234) fit.sim2 &lt;- simulate(fit0, nsim = 250) all.equal(fit.sim1, fit.sim2) ## [1] TRUE If the whole stock is of interest, for example, to inspect model predictions of \\(SSB\\), the user should use the + method with a fitted object including iterations. In such case the stock.n, catch.n and harvest slots of the stock object will be updated and the usual metrics can be computed and extracted, e.g. ssb(stk.pred). Figure 9.3 depicts the stock summary plot after adding estimation uncertainty through simulate. stk.pred &lt;- hke1567 + fit.sim stk0 &lt;- hke1567 + fit0 plot(FLStocks(simulated=stk.pred, fitted=stk0)) Figure 9.3: Stock summary of the simulated and fitted data 9.2 Prediction uncertainty 9.3 confidence interval coverage 9.4 Propagate uncertainty into stock assessment In a multistage stock assessment process as described in this book, it’s important to be able to propagate uncertainty across the different stages. This section describes methods to propagate uncertainty across stages and compares their outcomes in terms of stock assessment outputs. The idea is to add uncertainty as one moves from one stage to the next. If a stock has uncertainty on it’s growth parameters, or natural mortality, or any other quantity estimated or set during the input data preparation, the model fit uncertainty will be added to it by generating iterations in the input data which are then used to fit the stock assessment model. The suggested workflow is: Add uncertainty in growth or M parameters. Draw from the parameters distribution. Compute metrics for stock assessment. If there’s uncertainty in growth parameters use slicing to created iterations of metrics by age, e.g. catch at age and index at age. If there’s uncertainty in M parameters draw from the distribution and generate iterations of the M matrix. If both draw from growth and M parameters, potentially having into account correlation between those parameters, and generate iterations of age based metrics and M. Fit the stock assessment model to each iteration Simulate from each fit Aggregate results in single FLStock object. In this section we give an example of how uncertainty in natural mortality, set up using the m() method and the class a4aM (see chapter XX), is propagated through the stock assessment. We’ll use the stock of Red Mullet in the Mediterranean GSA 1 (see Introduction for details) and 3 methods to add estimation uncertainty (step 5 above): Take one draw of the fit Take n draws of the fit and summarize with the median Take n draws of the fit and combine all These outcomes will be compared with a fit across M iterations without any sampling from the fit. Using a4a methods we’ll model natural mortality using a negative exponential model by age, Jensen’s estimator for the level and no time trend. We include multivariate normal uncertainty using the mvrnorm() method and create 250 iterations. nits &lt;- 250 shape &lt;- FLModelSim(model=~exp(-age-0.5)) level &lt;- FLModelSim(model=~k^0.66*t^0.57, params = FLPar(k=0.4, t=10), vcov=matrix(c(0.002, 0.01,0.01, 1), ncol=2)) #trend &lt;- FLModelSim(model=~b, params=FLPar(b=0.5), vcov=matrix(0.02)) m4 &lt;- a4aM(shape=shape, level=level) m4 &lt;- mvrnorm(nits, m4) range(m4)[] &lt;- range(stk00)[] range(m4)[c(&quot;minmbar&quot;,&quot;maxmbar&quot;)]&lt;-c(1,1) flq &lt;- m(m4)[] quant(flq) &lt;- &quot;age&quot; stk0 &lt;- propagate(stk00, nits) m(stk0) &lt;- flq The M matrix for this stock is shown in Figure9.4). Figure 9.4: Natural mortality generated from M model’s parameter uncertainty We fit the same model to the new stock object which has uncertainty in the natural mortality and add estimation uncertainty following the methods described above. # create objects to store the results stk01 &lt;- stk0 stk02 &lt;- stk0 stk03 &lt;- propagate(stk00, nits*nits) # run without estimation unceratainty stk04 &lt;- stk00 + sca(stk0, idx00) for(i in 1:nits){ stk &lt;- iter(stk0, i) fit &lt;- sca(stk, idx00) # Method 1 iter(stk01, i) &lt;- stk + simulate(fit, 1) # Method 2 iter(stk02, i) &lt;- qapply(stk + simulate(fit, nits), iterMedians) # Method 3 iter(stk03, (nits*(i-1)+1):(nits*i)) &lt;- stk + simulate(fit, nits) } plot(FLStocks(&quot;M&quot;=stk04, &quot;M + 1 estimation sample&quot;=stk01, &quot;M + estimation median&quot;=stk02, &quot;M + n estimation samples&quot;=stk03)) Figure 9.5: Stock summary. Stock metrics computed over fits including uncertainty in M and estimation uncertainty References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
