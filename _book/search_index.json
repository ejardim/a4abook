[["diagnostics.html", "9 Diagnostics 9.1 Residuals 9.2 Predictive skill 9.3 Aggreagted catch in weight 9.4 Fit summary, information and cross-validation metrics 9.5 The package a4adiags 9.6 Retrospective analysis 9.7 Hindcast", " 9 Diagnostics There’s a large number of diagnostics that can be computed for a stock assessment model, the framework implements several analysis of residuals, visualizations and statistics that can be used to evaluate the fit quality and chose across multiple fits. 9.1 Residuals Residuals are a ubiquos metrics to check quality of a fit. For sca() fits there are out-of-the-box methods to compute in the log scale, raw residuals (aka deviances), standardized residuals and pearson residuals. A set of plots to inspect residuals and evaluate fit quality and assumptions are implemented. Consider \\(x_{ay}\\) to be either a catch-at-age matrix (\\(C_{ay}\\)) or one abundance index (\\(I_{ay}\\)) and \\(d\\) to represent residuals. Raw residuals are compute by \\(d_{ay} = \\log{x_{ay}} - \\log{\\tilde{x}_{ay}}\\) and have distribution \\(N(0,\\upsilon^2_{a})\\). Standardized residuals will be compute with \\(d^s_{ay} = \\frac{d_{ay}}{\\hat{\\upsilon}^2_{a}}\\) where \\(\\hat{\\upsilon}^2_{a} = (n-1)^{-1} \\sum_y(d_{ay})^2\\). Pearson residuals scale raw residuals by the estimates of \\(\\sigma^2\\) or \\(\\tau^2\\), as such \\(d^p_{ay} = \\frac{d_{ay}}{\\tilde{\\upsilon}^2_{a}}\\) where \\(\\tilde{\\upsilon}^2_{a} = \\tilde{\\sigma}^2_{a}\\) for catches, or \\(\\tilde{\\upsilon}^2_{a} = \\tilde{\\tau}^2_{a}\\) for each index of abundance. The residuals() method will compute these residuals and generate a object which can be plotted using a set of packed methods. The argument type will allow the user to chose which residuals will be computed. By default the method computes standardized residuals. fit &lt;- sca(ple4, ple4.indices) d_s &lt;- residuals(fit, ple4, ple4.indices) Figure 9.1 shows a scatterplot of standardized residuals with a smoother to guide (or mis-guide …) your visual analysis. Note that the standardization should produce residuals with variance=1, which means that most residual values should be between \\(\\sim -2\\) and \\(\\sim 2\\). plot(d_s) Figure 9.1: Standardized residuals for abundance indices and catch numbers (catch.n). Each panel is coded by age class, dots represent standardized residuals and lines a simple smoother. When plotting residuals by default the auxiliar line is a smoother. However it’s possible to use other type of lines by setting the argument “auxline” in plot. The argument can take the values used by xyplot, which are (from panel.xyplot help page) one or more of the following: “p”, “l”, “h”, “b”, “o”, “s”, “S”, “g”, “r”, “a”, “smooth”, and “spline”. If type has more than one element, an attempt is made to combine the effect of each of the components. The behaviour if any of the first five are included is similar to the effect of the corresponding type in plot: “p” and “l” stand for points and lines respectively; “b” and “o” (for ‘overlay’) plot both; “h” draws vertical (or horizontal if horizontal = TRUE) line segments from the points to the origin. Types “s” and “S” are like “l” in the sense that they join consecutive points, but instead of being joined by a straight line, points are connected by a vertical and a horizontal segment forming a ‘step’, with the vertical segment coming first for “s”, and the horizontal segment coming first for “S”. “g” adds a reference grid. Type “r” adds a linear regression line, “smooth” adds a loess fit, “spline” adds a cubic smoothing spline fit, and “a” draws line segments joining the average y value for each distinct x value. Figure 9.2 shows a regression line over the residuals instead of the loess smooother. plot(d_s, auxline=&quot;r&quot;) Figure 9.2: Standardized residuals for abundance indices and catch numbers (catch.n). Each panel is coded by age class, dots represent standardized residuals and lines a simple smoother. The common bubble plot (bubble()) are shown in Figure 9.3. It shows the same information as Figure 9.1 but in a multivariate perspective. bubbles(d_s) Figure 9.3: Bubbles plot of standardized residuals for abundance indices and for catch numbers (catch.n). Figure 9.4 shows a quantile-quantile plot to assess how well standardized residuals match a normal distribution. qqmath(d_s) Figure 9.4: Quantile-quantile plot of standardized residuals for abundance indices and catch numbers (catch.n). Each panel is coded by age class, dots represent standardized residuals and lines the normal distribution quantiles. Pearson residuals can be computed and plotted the same way as standardized residuals by setting fit='pearson' (Figure 9.5). d_p &lt;- residuals(fit, ple4, ple4.indices, type=&#39;pearson&#39;) plot(d_p) Figure 9.5: Pearson residuals for abundance indices and catch numbers (catch.n). Each panel is coded by age class, dots represent standardized residuals and lines a simple smoother. Finally, the raw residuals are computed by setting fit='deviances' and plotted the same way as before (Figure 9.6). These residuals are usefull to identify which data points are not well modelled, showing a large dispersion of the residuals and requiring more attention from the analyst. d_r &lt;- residuals(fit, ple4, ple4.indices, type=&#39;deviances&#39;) plot(d_r) Figure 9.6: Raw residuals for abundance indices and catch numbers (catch.n). Each panel is coded by age class, dots represent standardized residuals and lines a simple smoother. 9.2 Predictive skill An important feature of stock assessment model fits is the capacity to predict, since one of the most important analysis done with these fits is forecasting future fishing opportunities under pre-defined conditions. The a4a framework implements a visualization of the fit’s predictive skill for both catch-at-age and abundance indices. These are generated by the method plot() with the fit object and a FLStock (Figure 9.7) or FLIndices (Figure ??) object as arguments. plot(fit, ple4) Figure 9.7: Predict and observed catch-at-age plot(fit, ple4.indices) Figure 9.8: Predict and observed abundance-at-age Figure 9.9: Predict and observed abundance-at-age Figure 9.10: Predict and observed abundance-at-age Figure 9.11: Predict and observed abundance-at-age Figure 9.12: Predict and observed abundance-at-age Figure 9.13: Predict and observed abundance-at-age 9.3 Aggreagted catch in weight Although a statistical catch-at-age model assumes errors in catch-at-age and, as such, errors in the total catch in weight, there’s still interest to evaluate how close the model estimates are of the observed catch in weight1. The implementation of this diagnopstics is done through the method computeCatchDiagnostics(), which can be visualized with plot() (Figure @ref(c_d)). c_d &lt;- computeCatchDiagnostics(fit, ple4) plot(c_d) Figure 9.14: Diagnostics for age aggregated catch in weight 9.4 Fit summary, information and cross-validation metrics To get information about the likelihood fit the method fitSumm() can be used to report number of parameters (npar), negative log-likelkihood (nlogl), ADMB maximum gradient par (maxgrad), number of observations (nobs), generalized cross validation score (gcv), convergence flag (convergence) and acceptance rate (accrate) relevant for MCMC fits only. The second part refers to the likelihood value for each component. fitSumm(fit) ## iters ## 1 ## nopar 2.870000e+02 ## nlogl -3.823602e+02 ## maxgrad 2.060663e-04 ## nobs 1.728000e+03 ## gcv 1.185680e-01 ## convergence 0.000000e+00 ## accrate NA ## nlogl_comp1 -1.058450e+03 ## nlogl_comp2 6.695020e+01 ## nlogl_comp3 5.643150e+01 ## nlogl_comp4 4.025550e+02 ## nlogl_comp5 5.836470e+01 ## nlogl_comp6 6.057810e+01 ## nlogl_comp7 3.121530e+01 Information criteria based metrics are reported with the methods: AIC(fit) ## [1] -190.7205 BIC(fit) ## [1] 1374.784 9.5 The package a4adiags The package a4adiags contains some additional diagnostics based on the reference. Runs test checks weather the residuals are randomly distributed. A “run” is a sequence of the same sign residuals. Few runs indicate a trend or a correlation in the residuals while too many runs may suggest overfitting. The primary output of a runstest is a p-value where: a high p value \\((p\\leq 0.05)\\) suggests that the residuals are randomly distributed, a low p value indicates a non-random pattern in the residuals. library(a4adiags) ## Loading required package: ggplot2 ## ## Attaching package: &#39;ggplot2&#39; ## The following object is masked from &#39;package:FLCore&#39;: ## ## %+% ## Loading required package: ggplotFL ## ## Attaching package: &#39;a4adiags&#39; ## The following object is masked _by_ &#39;.GlobalEnv&#39;: ## ## fit theme_set(theme_bw()) fit &lt;- sca(mut09, mut09.idx, fmod = ~factor(age) + s(year, k = 8)) res &lt;- residuals(fit, mut09, mut09.idx) plotRunstest(fit, mut09.idx, combine = F) + theme_bw() + facet_wrap(~age) Figure 9.15: Runstest for the abundance index plotRunstest(catch.n(mut09), catch.n(mut09 + fit), combine = F) + theme_bw() + facet_wrap(~age) Figure 9.16: Runstest for the catch by age Green shading indicates no evidence \\((p &lt; 0.05)\\) and red shading evidence \\((p &gt;0.05)\\) to reject the hypothesis of a randomly distributed time-series of residuals, respectively. The shaded (green/red) area spans three residual standard deviations to either side from zero, and the red points outside of the shading violate the ‘\\(3\\sigma\\) limit’ for that series. 9.6 Retrospective analysis A legacy analysis from back when stock assessments were done with VPAs (REF Sheppeard, …), not so relevant with statistical catch at age models, which do not backwarsd fit fishing mortality and abundance as those models did. Cadrin (2025) notes the circularity of arguments when using retrospective analysis to make decisions about the stock assessment fit. Nevertheless, most experts still relly on this analysis to make decisions about the fit. The most common statistic used to summarize the retrospective analysis is Mohn’s rho (REF). Retrospective analysis consists on removing the most recent year of data, refit the model and compare estimates of metrics, e.g. the estimate of fishing mortality in year y-1 by each fit. The rationale is that a stable well fitted model would have similar estimates in both fits. In the example below the fishing mortality model is kept for all fits, without updating the smoothness factor. fit0 &lt;- sca(ple4, ple4.indices) n &lt;- 5 nret &lt;- as.list(1:n) stks &lt;- FLStocks(lapply(nret, function(x){window(ple4, end=(range(ple4)[&quot;maxyear&quot;]-x))})) idxs &lt;- lapply(nret, function(x){window(ple4.indices, end=(range(ple4)[&quot;maxyear&quot;]-x))}) fits &lt;- scas(stks, idxs, fmodel=list(fmodel(fit0))) stks &lt;- stks + fits stks[[6]] &lt;- ple4 + simulate(fit0, 250) Note fmodel doesn’t change: ## $fit1 ## ~te(age, year, k = c(6, 30), bs = &quot;tp&quot;) + s(age, k = 6) ## &lt;environment: 0x57939a4eea80&gt; ## ## $fit2 ## ~te(age, year, k = c(6, 30), bs = &quot;tp&quot;) + s(age, k = 6) ## &lt;environment: 0x57939a4eea80&gt; ## ## $fit3 ## ~te(age, year, k = c(6, 30), bs = &quot;tp&quot;) + s(age, k = 6) ## &lt;environment: 0x57939a4eea80&gt; ## ## $fit4 ## ~te(age, year, k = c(6, 30), bs = &quot;tp&quot;) + s(age, k = 6) ## &lt;environment: 0x57939a4eea80&gt; ## ## $fit5 ## ~te(age, year, k = c(6, 30), bs = &quot;tp&quot;) + s(age, k = 6) ## &lt;environment: 0x57939a4eea80&gt; The retrospective plot shown below presents the current fit with uncertainty and each retrospective fit on top. If the retrospective fit is not whithin the confidence interval of the current fit the analyst can argue that the estiate is different and as such reflecting a “poor” fit. plot(window(stks, start=2005)) Figure 9.17: Retrospective analysis of the plaice in ICES area IV stock One could use specific submodels and pass them to the fitting function scas, including with some adjustments to take into account the data reduction. In the next example the fishing mortality model is set reducing the smoothness taking into account the length of the dataset. Not considering the adjustment of the model to the new dataset may result in comparisons across models which are very different due to the relationship between information contained in the data and the number of parameters in the model. This issue is more relevant for stocks with shorter time series. n &lt;- 5 nret &lt;- as.list(1:n) stks &lt;- FLStocks(lapply(nret, function(x){window(ple4, end=(range(ple4)[&quot;maxyear&quot;]-x))})) idxs &lt;- lapply(nret, function(x){window(ple4.indices, end=(range(ple4)[&quot;maxyear&quot;]-x))}) # each model will have smootheness scaled to length of time series fmod &lt;- lapply(stks, defaultFmod) fits &lt;- scas(stks, idxs, fmodel=fmod) stks &lt;- stks + fits stks[[6]] &lt;- ple4 + simulate(fit0, 250) Note fmodel changes: ## $fit1 ## ~te(age, year, k = c(6, 30), bs = &quot;tp&quot;) + s(age, k = 6) ## &lt;environment: 0x579395a40140&gt; ## ## $fit2 ## ~te(age, year, k = c(6, 29), bs = &quot;tp&quot;) + s(age, k = 6) ## &lt;environment: 0x579393a93250&gt; ## ## $fit3 ## ~te(age, year, k = c(6, 29), bs = &quot;tp&quot;) + s(age, k = 6) ## &lt;environment: 0x57939fbe5ad8&gt; ## ## $fit4 ## ~te(age, year, k = c(6, 28), bs = &quot;tp&quot;) + s(age, k = 6) ## &lt;environment: 0x57939e48b958&gt; ## ## $fit5 ## ~te(age, year, k = c(6, 28), bs = &quot;tp&quot;) + s(age, k = 6) ## &lt;environment: 0x57939e3b5f28&gt; And the retrospective plot plot(window(stks, start=2005)) Figure 9.18: Retrospective analysis of the plaice in ICES area IV stock 9.7 Hindcast Some analysts believe this is the most important diagnostic since total catch should be trusted. Needless to say we don’t agree and consider reported catch in weight one of the less reliable pieces of information available for stock assessment.↩︎ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
